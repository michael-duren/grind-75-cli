// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: queries.sql

package dbgen

import (
	"context"
	"database/sql"
	"time"
)

const completeReview = `-- name: CompleteReview :exec
UPDATE reviews
SET completed = 1
WHERE id = ?
`

func (q *Queries) CompleteReview(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, completeReview, id)
	return err
}

const createProblem = `-- name: CreateProblem :exec
INSERT INTO problems (id, slug, title, url, duration, difficulty_id)
VALUES (?, ?, ?, ?, ?, ?)
ON CONFLICT(slug) DO UPDATE SET
    title = excluded.title,
    url = excluded.url,
    duration = excluded.duration,
    difficulty_id = excluded.difficulty_id
`

type CreateProblemParams struct {
	ID           int64  `db:"id" json:"id"`
	Slug         string `db:"slug" json:"slug"`
	Title        string `db:"title" json:"title"`
	Url          string `db:"url" json:"url"`
	Duration     int64  `db:"duration" json:"duration"`
	DifficultyID string `db:"difficulty_id" json:"difficulty_id"`
}

func (q *Queries) CreateProblem(ctx context.Context, arg CreateProblemParams) error {
	_, err := q.db.ExecContext(ctx, createProblem,
		arg.ID,
		arg.Slug,
		arg.Title,
		arg.Url,
		arg.Duration,
		arg.DifficultyID,
	)
	return err
}

const createReview = `-- name: CreateReview :exec
INSERT INTO reviews (problem_id, review_date)
VALUES (?, ?)
`

type CreateReviewParams struct {
	ProblemID  int64     `db:"problem_id" json:"problem_id"`
	ReviewDate time.Time `db:"review_date" json:"review_date"`
}

func (q *Queries) CreateReview(ctx context.Context, arg CreateReviewParams) error {
	_, err := q.db.ExecContext(ctx, createReview, arg.ProblemID, arg.ReviewDate)
	return err
}

const createTopic = `-- name: CreateTopic :exec
INSERT INTO topics (id, name)
VALUES (?, ?)
ON CONFLICT(id) DO NOTHING
`

type CreateTopicParams struct {
	ID   string `db:"id" json:"id"`
	Name string `db:"name" json:"name"`
}

func (q *Queries) CreateTopic(ctx context.Context, arg CreateTopicParams) error {
	_, err := q.db.ExecContext(ctx, createTopic, arg.ID, arg.Name)
	return err
}

const getAllProblemReviews = `-- name: GetAllProblemReviews :many
SELECT id, problem_id, review_date, completed, created_at, notes FROM reviews
ORDER BY problem_id, review_date DESC
`

func (q *Queries) GetAllProblemReviews(ctx context.Context) ([]Review, error) {
	rows, err := q.db.QueryContext(ctx, getAllProblemReviews)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Review
	for rows.Next() {
		var i Review
		if err := rows.Scan(
			&i.ID,
			&i.ProblemID,
			&i.ReviewDate,
			&i.Completed,
			&i.CreatedAt,
			&i.Notes,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllProblemTopics = `-- name: GetAllProblemTopics :many
SELECT pt.problem_id, t.id, t.name
FROM problem_topics pt
JOIN topics t ON pt.topic_id = t.id
ORDER BY pt.problem_id, t.name
`

type GetAllProblemTopicsRow struct {
	ProblemID int64  `db:"problem_id" json:"problem_id"`
	ID        string `db:"id" json:"id"`
	Name      string `db:"name" json:"name"`
}

func (q *Queries) GetAllProblemTopics(ctx context.Context) ([]GetAllProblemTopicsRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllProblemTopics)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllProblemTopicsRow
	for rows.Next() {
		var i GetAllProblemTopicsRow
		if err := rows.Scan(&i.ProblemID, &i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDifficulty = `-- name: GetDifficulty :one
SELECT id, name FROM difficulty_levels
WHERE id = ?
`

func (q *Queries) GetDifficulty(ctx context.Context, id string) (DifficultyLevel, error) {
	row := q.db.QueryRowContext(ctx, getDifficulty, id)
	var i DifficultyLevel
	err := row.Scan(&i.ID, &i.Name)
	return i, err
}

const getProblem = `-- name: GetProblem :one
SELECT id, slug, title, url, duration, difficulty_id, created_at FROM problems
WHERE id = ? LIMIT 1
`

func (q *Queries) GetProblem(ctx context.Context, id int64) (Problem, error) {
	row := q.db.QueryRowContext(ctx, getProblem, id)
	var i Problem
	err := row.Scan(
		&i.ID,
		&i.Slug,
		&i.Title,
		&i.Url,
		&i.Duration,
		&i.DifficultyID,
		&i.CreatedAt,
	)
	return i, err
}

const getProblemBySlug = `-- name: GetProblemBySlug :one
SELECT id, slug, title, url, duration, difficulty_id, created_at FROM problems
WHERE slug = ? LIMIT 1
`

func (q *Queries) GetProblemBySlug(ctx context.Context, slug string) (Problem, error) {
	row := q.db.QueryRowContext(ctx, getProblemBySlug, slug)
	var i Problem
	err := row.Scan(
		&i.ID,
		&i.Slug,
		&i.Title,
		&i.Url,
		&i.Duration,
		&i.DifficultyID,
		&i.CreatedAt,
	)
	return i, err
}

const getProblemTopics = `-- name: GetProblemTopics :many
SELECT t.id, t.name FROM topics t
JOIN problem_topics pt ON t.id = pt.topic_id
WHERE pt.problem_id = ?
`

func (q *Queries) GetProblemTopics(ctx context.Context, problemID int64) ([]Topic, error) {
	rows, err := q.db.QueryContext(ctx, getProblemTopics, problemID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Topic
	for rows.Next() {
		var i Topic
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserProgress = `-- name: GetUserProgress :one
SELECT problem_id, status, last_attempted_at, attempts, created_at, updated_at FROM user_progress
WHERE problem_id = ? LIMIT 1
`

func (q *Queries) GetUserProgress(ctx context.Context, problemID int64) (UserProgress, error) {
	row := q.db.QueryRowContext(ctx, getUserProgress, problemID)
	var i UserProgress
	err := row.Scan(
		&i.ProblemID,
		&i.Status,
		&i.LastAttemptedAt,
		&i.Attempts,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const linkProblemTopic = `-- name: LinkProblemTopic :exec
INSERT INTO problem_topics (problem_id, topic_id)
VALUES (?, ?)
ON CONFLICT(problem_id, topic_id) DO NOTHING
`

type LinkProblemTopicParams struct {
	ProblemID int64  `db:"problem_id" json:"problem_id"`
	TopicID   string `db:"topic_id" json:"topic_id"`
}

func (q *Queries) LinkProblemTopic(ctx context.Context, arg LinkProblemTopicParams) error {
	_, err := q.db.ExecContext(ctx, linkProblemTopic, arg.ProblemID, arg.TopicID)
	return err
}

const listDifficulties = `-- name: ListDifficulties :many
SELECT id, name FROM difficulty_levels
`

func (q *Queries) ListDifficulties(ctx context.Context) ([]DifficultyLevel, error) {
	rows, err := q.db.QueryContext(ctx, listDifficulties)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DifficultyLevel
	for rows.Next() {
		var i DifficultyLevel
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPendingReviews = `-- name: ListPendingReviews :many
SELECT r.id, r.problem_id, r.review_date, r.completed, r.created_at, r.notes, p.title, p.slug FROM reviews r
JOIN problems p ON r.problem_id = p.id
WHERE r.completed = 0 AND r.review_date <= ?
ORDER BY r.review_date
`

type ListPendingReviewsRow struct {
	ID         int64          `db:"id" json:"id"`
	ProblemID  int64          `db:"problem_id" json:"problem_id"`
	ReviewDate time.Time      `db:"review_date" json:"review_date"`
	Completed  bool           `db:"completed" json:"completed"`
	CreatedAt  time.Time      `db:"created_at" json:"created_at"`
	Notes      sql.NullString `db:"notes" json:"notes"`
	Title      string         `db:"title" json:"title"`
	Slug       string         `db:"slug" json:"slug"`
}

func (q *Queries) ListPendingReviews(ctx context.Context, reviewDate time.Time) ([]ListPendingReviewsRow, error) {
	rows, err := q.db.QueryContext(ctx, listPendingReviews, reviewDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListPendingReviewsRow
	for rows.Next() {
		var i ListPendingReviewsRow
		if err := rows.Scan(
			&i.ID,
			&i.ProblemID,
			&i.ReviewDate,
			&i.Completed,
			&i.CreatedAt,
			&i.Notes,
			&i.Title,
			&i.Slug,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProblems = `-- name: ListProblems :many
SELECT id, slug, title, url, duration, difficulty_id, created_at FROM problems
ORDER BY id
`

func (q *Queries) ListProblems(ctx context.Context) ([]Problem, error) {
	rows, err := q.db.QueryContext(ctx, listProblems)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Problem
	for rows.Next() {
		var i Problem
		if err := rows.Scan(
			&i.ID,
			&i.Slug,
			&i.Title,
			&i.Url,
			&i.Duration,
			&i.DifficultyID,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTopics = `-- name: ListTopics :many
SELECT id, name FROM topics
`

func (q *Queries) ListTopics(ctx context.Context) ([]Topic, error) {
	rows, err := q.db.QueryContext(ctx, listTopics)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Topic
	for rows.Next() {
		var i Topic
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserProblems = `-- name: ListUserProblems :many
SELECT 
  p.id AS problem_id, 
  p.slug, 
  p.title, 
  p.url, 
  p.duration, 
  dl.id AS difficulty_id,
  dl.name AS difficulty_name,
  up.status,
  up.last_attempted_at,
  up.attempts
FROM problems p
LEFT JOIN user_progress up ON p.id = up.problem_id
LEFT JOIN difficulty_levels dl ON p.difficulty_id = dl.id
ORDER BY p.id
`

type ListUserProblemsRow struct {
	ProblemID       int64          `db:"problem_id" json:"problem_id"`
	Slug            string         `db:"slug" json:"slug"`
	Title           string         `db:"title" json:"title"`
	Url             string         `db:"url" json:"url"`
	Duration        int64          `db:"duration" json:"duration"`
	DifficultyID    sql.NullString `db:"difficulty_id" json:"difficulty_id"`
	DifficultyName  sql.NullString `db:"difficulty_name" json:"difficulty_name"`
	Status          sql.NullString `db:"status" json:"status"`
	LastAttemptedAt sql.NullTime   `db:"last_attempted_at" json:"last_attempted_at"`
	Attempts        sql.NullInt64  `db:"attempts" json:"attempts"`
}

func (q *Queries) ListUserProblems(ctx context.Context) ([]ListUserProblemsRow, error) {
	rows, err := q.db.QueryContext(ctx, listUserProblems)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListUserProblemsRow
	for rows.Next() {
		var i ListUserProblemsRow
		if err := rows.Scan(
			&i.ProblemID,
			&i.Slug,
			&i.Title,
			&i.Url,
			&i.Duration,
			&i.DifficultyID,
			&i.DifficultyName,
			&i.Status,
			&i.LastAttemptedAt,
			&i.Attempts,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertUserProgress = `-- name: UpsertUserProgress :exec
INSERT INTO user_progress (problem_id, status, last_attempted_at, attempts, updated_at)
VALUES (?, ?, ?, ?, CURRENT_TIMESTAMP)
ON CONFLICT(problem_id) DO UPDATE SET
    status = excluded.status,
    last_attempted_at = excluded.last_attempted_at,
    attempts = excluded.attempts,
    updated_at = CURRENT_TIMESTAMP
`

type UpsertUserProgressParams struct {
	ProblemID       int64        `db:"problem_id" json:"problem_id"`
	Status          string       `db:"status" json:"status"`
	LastAttemptedAt sql.NullTime `db:"last_attempted_at" json:"last_attempted_at"`
	Attempts        int64        `db:"attempts" json:"attempts"`
}

func (q *Queries) UpsertUserProgress(ctx context.Context, arg UpsertUserProgressParams) error {
	_, err := q.db.ExecContext(ctx, upsertUserProgress,
		arg.ProblemID,
		arg.Status,
		arg.LastAttemptedAt,
		arg.Attempts,
	)
	return err
}
